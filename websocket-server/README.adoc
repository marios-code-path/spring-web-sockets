= Create WebSocket Servers with Spring WebSocketServer
Mario Gray <mgray@pivotal.io>
:Author Initials: MVG
:toc:
:icons:
:numbered:
:imagesdir: ./graphics
:website: https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html
:note: Drain the [BAYEUX]

== This Demo
This demo will stand up Spring application service that exposes a WebSocket service through the Spring 5's reactive https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#spring-webflux[WebSockets] API.
Typically, for inter-service comms, use a more traditional messaging system to deliver and expect events between services for example - messaging brokers such as https://kafka.apache.org/[Kafka], https://www.rabbitmq.com/[RabbitMq], etc.. 
WebSockets is an https://tools.ietf.org/html/rfc6455[IETF] standard and https://www.w3.org/TR/websockets/[W3C] API that provides a convenient way to issue and consume data streams across the Internet. WebSockets is mainly used at edge consumption where data is being requested outside of your Service boundaries.

#A sample graph of services and then of a mix of clients that connect

== WebSocket Server
Spring's WebSocket API is new in Spring 5, and enables reactive event and connection handling. We will introduce a single WebSocket handler, and show whats needed to get started using Spring's `WebSocketServer` support.
You'll want to start a new Spring project using start.spring.io[this link] to autogenerate a maven based POM.  If you go with a different approach, just make sure to 
have `webflux`, and `lombok` projects.

To get started, wire in a https://docs.spring.io/spring/docs/4.0.0.M1_to_4.2.0.M2/Spring%20Framework%204.0.0.M1/org/springframework/web/socket/adapter/WebSocketHandlerAdapter.html[`WebSocketHandlerAdapter`] to handle our web socket handshake, upgrade, and other connection details.

.socket_handler_adapter
[source,java]
----
    @Bean
    WebSocketHandlerAdapter socketHandlerAdapter() {
        return new WebSocketHandlerAdapter();
    }
----

Next, create the websocket session handler. The simplest way to do this to use the functional interface for `WebSocketHandler` and implement it's handle method to manage our stream response. In this, we will use the `Flux.interval` operator and push it's output back to the session.
The simplest way is to https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#map-java.util.function.Function-[`Flux.map` or transform] 
the integer output into a string then compose a message using https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/reactive/socket/WebSocketSession.html#textMessage-java.lang.String-[`session.textMessage(String)`] or one of it's similar methods For this response.

.socket_session_handler
[source,java]
----
    WebSocketHandler webSocketHandler() {
        return session ->
                session.send(
                        Flux.interval(Duration.ofSeconds(1))
                                .map(n -> n.toString())
                                .map(session::textMessage)
                ).and(session.receive()
                        .map(WebSocketMessage::getPayloadAsText)
                        .doOnNext(msg -> log.info("Prime#: " + msg))
                        .doOnSubscribe(sub -> log.info("Started." + session.getId()))
                        .doFinally(sig -> log.info("Complete." + session.getId()))
                );
    }
----

WebSocket Sessions are wraped within the reactive https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[`Mono`] type that supports the the https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#and-org.reactivestreams.Publisher-[`and()`] operator for chaining other publisher's termination signal.
We expect a client to respond with numbers it finds as prime. So, compose the extra step with the `session.receive()` publisher that emits, and logs messages to console.
Additionally, we'll make use of the `do...()` handlers to react to session events so we can do things like clean up resources after the connection is over.

Finally, to map URI's to our handler we wire in a reactive `SimpleUrlHandlerMapping` to delegate socket connections on URL `/ws/feed`.

.uri_handler_mapping
[source,java]
----
    @Bean
    HandlerMapping simpleUrlHandlerMapping() {
        SimpleUrlHandlerMapping simpleUrlHandlerMapping = new SimpleUrlHandlerMapping();
        RequestMappingHandlerMapping foo = new RequestMappingHandlerMapping();
        simpleUrlHandlerMapping.setUrlMap(Collections.singletonMap("/ws/feed",
                webSocketHandler()));
        simpleUrlHandlerMapping.setOrder(10);
        return simpleUrlHandlerMapping;
    }
----

Finally, we will execute this server app:

.server_app_main
[source,java]
----
    public static void main(String[] args) {
        SpringApplication.run(WebSocketConfiguration.class, args);
    }
----

Start the application:

[source,bash]
----
$ mvn clean spring-boot:run
...
2018-04-26 15:36:54.330  INFO 10671 --- [           main] o.s.b.web.embedded.netty.NettyWebServer  : Netty started on port(s): 8080
----

Now we are ready to implement the client, and demonstrate the new server we just stood up!

== References/Readling List

* Spring WebFlux guide
** https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/web-reactive.html
** https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html

* Articles
** https://ordina-jworks.github.io/reactive/2016/12/12/Reactive-Programming-Spring-Reactor.html

* W3C Proposals
** https://tools.ietf.org/html/rfc6455

* Theory
** http://reactivex.io/documentation/operators.html
** https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/debounce.md


